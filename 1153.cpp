/*
자연수를 소수 + (다른 소수의 합으로 표현되는 수)로 나누어 재귀를 돌리고, 재귀의 depth가 3이 된다면 더이상 돌리지 않도록 했다.
이렇게 하니까 170ms정도 걸린다.
4중반복을 돌리면 2초정도 걸린다. 어떻게 해야 10ms 내로 줄일 수 있을까.

답을 보았다.

단순 반복으로 찾기보다, 골드바흐의 추측대로 짝수를 두 개의 소수로 표현하는 것을 응용하여
주어진 수가 짝수일 경우 단순하게 두 개의 짝수로 나눈 다음 각 짝수를 분해하면 된다. 쉽게 하려면 두 개 짝수 중 하나를 4로 고정하여 푼다.
  왜 4를 고르냐면, 나머지 수가 짝수이므로 네 개의 소수중 두 개가 채워지기 때문에, 다른 두개의 소수를 만들어야 한다. 이 때 4는 두 개의 소수로 표현되는 가장 작은 짝수이므로 계산하기 쉽다.
주어진 수가 홀수일 경우 두 개의 짝수로 나눠지지 않으므로 홀수, 홀수-5로 나눈 다음, 홀수-5가 짝수이므로 이 짝수를 분해하면 된다.

시간이 많이 걸렸던 이유는 에라토스테네스의 체를 느리게 적용하도록 구현했기 떄문이다.
2의 배수인 수들은 모두 참으로 저장, 3의 배수인 수들은 모두 참으로 저장... 을 반복한다음 나중에 검사할때 참인 값들은 소수가 아닌것이라고 보면 된다.
이렇게 하면 O(N^2)보다 빠르게 처리할 수 있다. 바깥 루프는 N번 돌지만, 내부 루프는 N/i번 돌기 때문에, N * (1/1+1/2+1/3...)이므로 O(NlogN)이 된다.
*/
#include <iostream>

using namespace std;

bool is_prime[1000001] = {false};

void make_prime(int N) {
    for (int i = 2; i <= N; i++) {
        for (int j = 2 * i; j <= N; j += i) {
            is_prime[j] = true;
        }
    }
}

int main() {
    int N;
    cout.tie(0);
    cin.tie(0)->sync_with_stdio(0);
    cin >> N;
    make_prime(N);
    if (N < 8) {
        cout << -1;
        return 0;
    }
    if (N % 2) {
        // 홀수
        N -= 5;
        cout << "2 3 ";
    } else {
        // 짝수
        N -= 4;
        cout << "2 2 ";
    }
    for (int i = 2; i<=N; i++) {
        if (!is_prime[N-i]) {
            cout << i << ' ' << N-i;
            return 0;
        }
    }
    cout << -1;
}

/*
앞 수 = x
y=ax+b
수열이 항상 양수는 아니다. 진동하면서 발산 가능
a,b 모두 정수, int의 범위임. 이를 브루트 포스로 유추하는 것 = 불가능

7 -24 69 -210
    7a+b = -24
- -24a+b = 69
------------
   31a   = -93
     a   = 3
이차 방정식으로 해도 되지만! 행렬로 다뤄보자
[ 7  1] [a] = [24]
[-24 1] [b] = [69]
[a] = [  7 1]^-1 [24]
[b] = [-24 1]    [69]
2차원 행렬의 역행렬
[a b]^-1 = 1/(ad-bc)[d -b]
[c d]    =       [-c a]
b = d = 1
1/(a-c) [1 -1]
        [-c a]
a = x1
c = x2
--------------
[a] = [x1 1]^-1 [x2] = [1   -1] [x2] * 1/(x1-x2) = [         x2-x3] / (x1-x2)
[b] = [x2 1]    [x3] = [-x2 x1] [x3]             = [-x2*x2 + x1*x3]
 */
#include <iostream>
using namespace std;

int main() {
    int N;
    int x[50];
    cin >> N;
    for (int i = 0; i < N; i++) {
        cin >> x[i];
    }
    // 1, 2개가 주어질 경우 A를 출력
    if (N <= 2) {
        // 하지만 그 두 개가 같은 경우는 앞으로 계속 같은 숫자만 나와야함
        if (N == 2 && x[0] == x[1]) {
            cout << x[0];
        } else {
            cout << 'A';
        }
        return 0;
    }
    // 역행렬 연산
    int c = x[0] - x[1], a, b;
    if (c == 0) {
        a = 1;
        b = 0;
    } else {
        // double/double로 해야만 정확한 a와 b를 찾을 수 있다고 생각했다.
        // 문제의 조건에서 a와 b가 정수라고 했으니, 결과값도 정수여야 한다.
        // 만약 이상한 정수값이 주어져도, 아래 검증 단계에서 오류를 탐지가능.
        a = (x[1] - x[2]) / c;
        b = (-x[1] * x[1] + x[0] * x[2]) / c;
    }
    // 입력으로 주어진 값들을 검증
    for (int i = 1; i < N; i++) {
        if (x[i - 1] * a + b != x[i]) {
            cout << 'B';
            return 0;
        }
    }
    cout << x[N - 1] * a + b;
}

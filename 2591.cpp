/*
 * 2591 숫자카드
 * 골드V
 */
#include <iostream>
int dp[41]{1, 1};
int f(int n) {
  if (!dp[n]) {
    dp[n] = f(n - 1) + f(n - 2);
  }
  return dp[n];
}
int main() {
  char str[41];
  scanf("%s", str);
  int count = 1, ans = 1;
  for (int i = 1; str[i]; i++) {
    int prev = str[i - 1] - '0', cur = str[i] - '0';
    if (prev == 0) {
      continue;
    }
    if (prev * 10 + cur < 35) {
      if (cur == 0) {
        ans *= f(count - 1);
        count = 1;
      } else {
        count++;
      }
    } else {
      ans *= f(count);
      count = 1;
    }
  }
  ans *= f(count);
  printf("%d", ans);
}
/*
34까지 카드를 갖고 있으므로...
단, 10, 20, 30은 무조건 묶여야 한다. 0인 카드는 없어서...

1231
------------
1 2 3 1
12 3 1
1 23 1
1 2 31
12 31
 = 5

12312
------------
1 2 3 1 2
1 23 1 2
1 23 12
1 2 31 2
1 2 3 12
12 3 1 2
12 31 2
12 3 12
= 8

어떻게 보면 극장좌석 문제처럼 볼 수 있다.
1부터 34사이의 숫자카드는 두 자리 수를 나타낼 수 있는 카드들도 있다.
만약 두 자리 수를 나타낼 수 있다면 그렇게 하거나 안하거나 둘 중에 하나다.
위의 예시를 보면 묶거나 안 묶거나 둘 중에 하나를 골랐더니 피보나치 배열이
나온다. 이런 범위를 찾아내어 전부 곱해주면 된다. 하지만 10, 20, 30인 경우도
있으니 이 경우에는 가능한 범위에서 제외해야한다. 01~09인 경우도 있으므로
건너뛰어야 한다.
*/

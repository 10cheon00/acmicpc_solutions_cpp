/*
현재 값에서 한 조각을 고르냐 반 조각을 고르냐...
만약 반 조각이 없다면 한 조각을 무조건 고르게 된다
만약 한 조각이 없다면 반 조각을 무조건 고르게 된다.
현재 가지고 있는 한 조각의 개수(i)와 반 조각의 개수(j)를 좌표로 하여
각 개수에 따라 나올 수 있는 조합의 수를 저장한다.
한 조각을 고르면 i-1, j+1의 위치에 있는 조합을 의미하고
반 조각을 고르면 i, j-1의 위치에 있는 조합을 의미한다.
둘을 더해 답을 낸다.
단 한 조각이 없는 경우와 반 조각이 없는 경우를 생각해 더한다.
*/
#include <iostream>
long long dp[31][31]{0};
long long f(int i, int j) {
  if (!dp[i][j]) {
    if (j > 0) {
      dp[i][j] += f(i, j - 1);
    }
    if (i > 0) {
      dp[i][j] += f(i - 1, j + 1);
    }
  }
  return dp[i][j];
}
int main() {
  int N;
  dp[0][0] = 1;
  while (1) {
    scanf("%d", &N);
    if (N == 0) {
      break;
    }
    printf("%lld\n", f(N - 1, 1));
  }
}